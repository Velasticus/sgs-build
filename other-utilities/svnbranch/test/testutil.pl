# testutil.pl -- Utilities to support testing.

################
# Use
################

use strict;
use warnings;
use Getopt::Std;
use File::Spec::Functions ':ALL';

################
# Variables
################

# Usage message
my $usage = "Usage: $0 [-nqv] [-t FROM:TO]
Options:
  -n  Dry run
  -q  Quiet
  -S  Stop on error
  -t  Run tests FROM through TO, inclusive
  -v  Verbose
Environment variables:
  INSTALL_DIR   Directory containing programs to test
  WC            Root directory for first working copy
  WC2           Root directory for second working copy";

# File containing standard output generated by the test
my $stdout = "/tmp/stdout$$";

# File containing standard error generated by the test
my $stderr = "/tmp/stderr$$";

# File containing status returned by the test
my $status = "/tmp/status$$";

# File containing the script generated to run the entire test
my $cmd = "/tmp/cmd$$";

# The number of the current test -- changed just before running the test
my $test_number = 0;

# The number of tests that passed
my $passed = 0;

# The number of tests that failed
my $failed = 0;

# The first test to run
my $first = 1;

# The last test to run, or 0 for no restriction
my $last = 0;

# The tempoary directory used as the default location for file
# repositories and working copies.
our $tmp_dir = get_tmp_dir();

# The main working copy
our $wc = $ENV{"WC"} || "$tmp_dir/wc";

# A second working copy
our $wc2 = $ENV{"WC2"} || "$tmp_dir/wc2";

# A directory containing the working copy for the trunk
our $trunk = "$wc/proj1/trunk";

# Escaped version
our $escaped_trunk = escape($trunk);

# Another directory containing the working copy for the trunk
our $trunk_copy = "$wc2/proj1/trunk";

# Escaped version
our $escaped_trunk_copy = escape($trunk_copy);

# A directory containing the working copy for different trunk
our $wrong_trunk = "$wc/proj2/trunk";

# Escaped version
our $escaped_wrong_trunk = escape($wrong_trunk);

# A directory containing a working copy for a branch associated with the
# trunk
our $branch = "$wc/proj1/branches/branch1";

# Escaped version
our $escaped_branch = escape($branch);

# Another directory containing a working copy for a branch associated
# with the trunk
our $branch_copy = "$wc2/proj1/branches/branch1";

# Escaped version
our $escaped_branch_copy = escape($branch_copy);

# A directory containing a working copy for another branch associated
# with the trunk
our $branch2 = "$wc/proj1/branches/branch2";

# Escaped version
our $escaped_branch2 = escape($branch2);

# Declare global flags for options
our($opt_n, $opt_q, $opt_t, $opt_S, $opt_v);

################
# Subroutines
################

# Checks the arguments to the test, and exits if there is a problem.
# Sets $opt_n, $opt_q, $opt_t and $opt_v as a side effect.
sub check_arguments {
    if (!getopts("nqvSt:")) {
	print STDERR "$usage\n";
	exit 1;
    } elsif (defined $opt_t) {
	if ($opt_t !~ /^([0-9]*):([0-9]*)$/) {
	    print STDERR "Bad -t value: $opt_t\n";
	    exit 1;
	}
	$first = $1 ? $1 : 1;
	$last = $2 ? $2 : 0;
    }
}

# Performs an individual test.  The first argument is the name of the
# test.  The second is one or more bash commands to set up the
# environment of the test.  The rest of the test will be skipped if this
# step ends with a non-zero return code.  The third argument is the bash
# commands for the operation under test.  The fourth argument command
# checks the results.  It should set the 'message' shell variable to a
# non-empty value describing the failure if the test failed.  The test
# will fail if the check ends with a non-zero return code.  The fifth
# argument performs cleanup after the test to return to a known state.
# The test will also fail if the cleanup ends with a non-zero return
# code.
sub test {
    my $name = shift @_;
    my $setup = shift @_;
    my $test = shift @_;
    my $check = shift @_;
    my $cleanup = $#_ < 0 ? "" : shift @_;

    $test_number++;
    if ($first > $test_number) {
	return;
    } elsif ($last != 0 && $last < $test_number) {
	return;
    }
    my $command = "# Test $test_number: $name
# Setup
set -x
rm -f $stdout $stderr $status
$setup
if [ \$? != 0 ]; then echo Failure: Setup failed; exit 1; fi
# Run test
$test > $stdout 2> $stderr
status=\$?
echo \$status > $status
# Check results
message=
$check
if [ \$? != 0 ]; then echo Failure: Check failed; exit 1; fi
# Print results
if [ \"\$message\" != '' ]; then echo Failure: \$message; fi";
    if ($cleanup) {
	$command .= "\n# Cleanup\n$cleanup\n" .
	    "if [ \$? != 0 ]; then echo Failure: Cleanup failed; exit 1; fi";
    }
    $command .= "\n[ \"\$message\" == '' ]";
    if (defined $opt_n) {
	print "$command\n";
    } else {
	open(OUTFILE, ">$cmd");
	print OUTFILE "$command\n";
	close(OUTFILE);
	my $output = `bash $cmd 2>&1`;
	my $cmd_status = $?;
	chomp(my $status_value = `cat $status 2> /dev/null`);
	if ($cmd_status == 0) {
	    $passed++;
	    if (defined $opt_v) {
		print "PASSED: Test $test_number, $name\n";
		print "*** Output ***\n";
		print "$output";
		print "*** Status: $status_value ***\n";
		print "*** Stdout ***\n";
		system "cat $stdout";
		print "*** Stderr ***\n";
		system "cat $stderr";
		print "***\n";
	    } elsif (!$opt_q) {
		print "PASSED: Test $test_number, $name\n";
	    }
	} else {
	    $failed++;
	    print "FAILED: Test $test_number, $name\n";
	    print "*** Output ***\n";
	    print "$output";
	    print "*** Status: $status_value ***\n";
	    print "*** Stdout ***\n";
	    system "cat $stdout 2> /dev/null";
	    print "*** Stderr ***\n";
	    system "cat $stderr 2> /dev/null";
	    print "***\n";
	    if ($opt_S) {
		print_results();
	    }
	}
    }
}

# Prints a summary of all test results.  Exits with a zero status if all
# tests passed, otherwise with 1.
sub print_results {
    if (!defined $opt_n) {
	if ($first != 1 || ($last != 0 && $last != $test_number)) {
	    print "Tests Run: $first:" .
		($last != 0 ? "$last" : "$test_number") . "\n";
	}
	print "Total Passed: $passed\nTotal Failed: $failed\n";
	system "rm -f $stdout $stderr $status $cmd";
	exit $failed == 0 ? 0 : 1;
    }
}

# Returns bash commands to check that the exit status was non-zero.
sub check_non_zero_exit {
    return
	"if [ \"\$message\" == '' ]; then\n" .
	"    if [ \$status == 0 ]; then message='Exit status was zero'\n" .
	"    fi\n" .
	"fi";
}

# Returns bash commands to check that the exit status was non-zero and
# that there was no output to standard output.
sub check_fail {
    return
	"if [ \"\$message\" == '' ]; then\n" .
	"    if [ \$status == 0 ]; then message='Exit status was zero'\n" .
	"    elif [ -s $stdout ]; then message='Standard output not empty'\n" .
	"    fi\n" .
	"fi";
}

# Returns bash commands to check that the exit status was zero and that
# there was no output to standard error.
sub check_pass {
    return
	"if [ \"\$message\" == '' ]; then\n" .
	"    if [ \$status != 0 ]; then message='Exit status was non-zero'\n" .
	"    elif [ -s $stderr ]; then message='Standard error not empty'\n" .
	"    fi\n" .
	"fi";
}

# Returns bash commands returned by the 'check_fail' and 'check_diff'
# subroutines.
sub check_diff_fail {
    my ($compare) = @_;
    return check_fail() . " &&\n" . check_diff($compare);
}


# Returns bash commands to check that the exit status was zero and that
# the output to standard error of the test matches the text provided by
# the first argument.
sub check_diff_pass {
    my ($compare) = @_;
    return
	"if [ \"\$message\" == '' ]; then\n" .
	"    if [ \$status != 0 ]; then message='Exit status was non-zero'\n" .
	"    fi\n" .
	"fi &&\n" .
	check_diff($compare);
}

# Returns bash commands to check that the output to standard error of
# the test matches the text provided by the first argument.
sub check_diff {
    my ($compare) = @_;
    return
	"if [ \"\$message\" == '' ]; then\n" .
	"    diff - $stderr <<EOF\n" .
	"$compare\n" .
	"EOF\n" .
	"    if [ \$? != 0 ]; then message='Wrong output'; fi\n" .
	"fi";
}

# Returns bash commands to check that the contents of the files
# specified by the two arguments are the same.
sub check_compare {
    my ($file1, $file2) = @_;
    return
	"if [ \"\$message\" == '' ]; then \n" .
	"    diff $file1 $file2\n" .
	"    if [ \$? != 0 ]; then message='Wrong file contents'; fi\n" .
	"fi";
}

# Returns the repository URL associated with a working copy directory or
# file.  Dies if the URL is not found or if there is a problem running
# the 'svn info' command.
sub get_repository_url {
    my ($arg) = @_;
    my $command = "svn info " . escape($arg);
    my @results = `$command`;
    if ($? == 0) {
	for (@results) {
	    if (/^URL: (.+)$/) {
		return "$1";
	    }
	}
    }
    die "URL not found: $arg\n";
}

# Returns a pathname string with spaces and shell meta characters
# escaped with backslashes.
sub escape {
    my ($pathname) = @_;
    # Put a backslash in front of the space character, as well as all of
    # the characters with special meaning in the shell:
    # ! " \ $ & ' ( ) * ; < > ? [ \ ] ` { | }
    $pathname =~ s/([ !"\$&'()*;<>?[\\\]`{|}])/\\$1/g;
    return $pathname;
}

# Returns the pathname for the temporary directory
sub get_tmp_dir {
    my $tmp_dir = -d '/tmp' ? '/tmp' : $ENV{TMPDIR} || $ENV{TEMP};
    my $pwd_command =
	# Use the -P flag on the Mac to get the physical location, which
	# is what Subversion uses in its error messages.
	$^O eq "darwin" ? "pwd -P"
	: "pwd";
    chomp(my $result = `cd $tmp_dir; $pwd_command`);
    return $result;
}

1;
